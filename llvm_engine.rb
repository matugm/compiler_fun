require 'llvm/execution_engine'
require 'llvm/core'

class LLVM_Engine
  include LLVM

  INT   = LLVM::Int
  PCHAR = LLVM::Pointer(LLVM::Int8)

  def initialize
    # Create module
    @mod = LLVM::Module.new('app')
    # function -> name, arguments, output type
    @main    = @mod.functions.add('main', [INT], INT)
    @puts_c  = @mod.functions.add('puts', [PCHAR], INT)
    @builder = generate_builder(@main)
    @locals  = {}

    @block_counter = 0
  end

  def generate_builder(func, name = 'entry')
    block = func.basic_blocks.append(name)
    build = Builder.new
    build.position_at_end(block)
  end

  def builder_from_block(block)
    build = Builder.new
    build.position_at_end(block)
  end

  def get_block(name)
    @block_counter += 1
    @main.basic_blocks.append("#{name}_#{@block_counter}")
  end

  def define_variable(inst)
    value = inst.value

    var = @locals.fetch(inst.variable) {

      if value.to_i > 0
        ptr = @builder.alloca(INT)
        @builder.store(LLVM::Int(value.to_i), ptr)
      else
        ptr   = define_string(value)
        alloc = @builder.alloca(PCHAR)
        ptr = @builder.store(@builder.gep(ptr, LLVM::Int(0)), alloc)
        ptr = alloc
      end

      @locals[inst.variable] = ptr
      return
    }

    # If var already exist, don't change @locals here
    if value.to_i > 0
      @builder.store(LLVM::Int(value.to_i), var)
    else
      ptr = define_string(value)
      @builder.store(@builder.gep(ptr, LLVM::Int(0)), var)
    end
  end

  def define_string(str)
    @builder.global_string_pointer(str)
  end

  def variable_add(inst)
    #
  end

  # int -> string (i32 -> i8*)
  def execute_method(name, *args)
    func = @mod.functions.named(name)
    ptr  = @locals.fetch(args.first) { abort "Invalid local variable - #{args.first}" }
    val  = @builder.load(ptr)
    @builder.call(func, val)
  end

  # Dereferences pointer to value
  def get_value(val)
    if val.is_a? IDENTIFIER
      var = @locals.fetch(val.content) { abort "Invalid local variable - #{val}" }
      @builder.load(var)
    else
      ptr = @builder.alloca(INT)
      @builder.store(LLVM::Int(val.content.to_i), ptr)
      @builder.load(ptr)
    end
  end

  # Idea: new END_BLOCK token generated by the parser
  # write to true_block until that token is found (end_if method on engine)
  # then create a new block for the rest of the code.
  # -> limitations of current system: no nested control flow
  def evaluate_if(input)
    cmp = evaluate_condition(input)

    @true_block  = get_block('true_block')
    @after_block = get_block('after_block')

    @builder.cond(cmp, @true_block, @after_block)

    @builder = builder_from_block(@true_block)
  end

  def end_block
    builder_from_block(@true_block).br(@after_block)
    @builder = builder_from_block(@after_block)
  end

  def end_while
    builder_from_block(@true_block).br(@condition_block)
    @builder = builder_from_block(@after_block)
  end

  def evaluate_while(input)
    cmp = evaluate_condition(input)

    @true_block  = get_block('true_block')
    @after_block = get_block('after_block')

    @builder.cond(cmp, @true_block, @after_block)

    @builder = builder_from_block(@true_block)
  end

  # icmp(pred, lhs, rhs, name = "") ⇒ LLVM::Instruction
  # cond(cond, iftrue, iffalse) ⇒ LLVM::Instruction
  def evaluate_condition(input)
    @condition_block = get_block('condition_block')
    @builder.br(@condition_block)

    @builder = builder_from_block(@condition_block)

    op = input.condition[1]
    left_hand  = get_value(input.condition[0])
    right_hand = get_value(input.condition[2])

    if op.class == DOUBLE_EQUALS
      return @builder.icmp(:eq, left_hand, right_hand)
    end

    if op.class == LESSER_THAN
      return @builder.icmp(:slt, left_hand, right_hand)
    end

    if op.class == GREATER_THAN
      return @builder.icmp(:sgt, left_hand, right_hand)
    end
  end

  def llvm_output
    puts
    puts @mod.dump
    puts
  end

  def run
    @builder.ret(LLVM::Int(0))
    llvm_output

    LLVM.init_jit
    ee = JITCompiler.new(@mod)

    # Run our main function
    ee.run_function(@main, 10)
  end
end
